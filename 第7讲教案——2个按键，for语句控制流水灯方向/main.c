/****************************************************************
 * 实验板：  创客海51单片机实验板，以STC89C52单片机为核心，适用于51系列单片机
 * 源代码：  源码经过精心调试，逐行注释，倾心录制高品质视频教程，制作PPT文档教程
 * 温馨提示：需要开源例程源码，请到创客海技术论坛学习、讨论、下载！
 * 淘宝店铺：创客海社区一号店/二号店，希望您支持，感谢您的惠顾！
 * 程序目的：学习主函数的创建方法
 * 函数功能: 创建流水灯方法，if语句，for循环语句的用法
*******************************************************************************/

#include <STC89C5xRC.H>

/*******************************************************************************
* 延时子函数 : Delay1ms
* 函数功能	 : 延时1ms
*******************************************************************************/
void Delay1ms(unsigned int ms)		//@11.0592MHz
{
    while(ms--)
    {
        unsigned char i, j;
        ;
        i = 2;
        j = 199;
        do
        {
            while (--j);
        }
        while (--i);
    }
}
/*******************************************************************************
* 主函数    : main
* 函数功能	: 按一下K3键，产生一串LED灯左流水移动，K4产生一串右流水移动
*             for循环语句的循环方式，已知循环次数
*******************************************************************************/
void main()
{
    while(1)                          //主循环
    {
        unsigned char n,Num;
        if(P30==0)		              //判断K1按键是否按下，P30==0,被按下
        {
            Delay1ms(50);             //消抖
            if(P30==0)		          //判断K1按键是否按下，P30==0,被按下
            {
                while(P30==0);        //等待按键释放

                for(n=0; n<8; n++)    //后面不能加;号
                {
                    Num=0x01;         //左移0X01, 0000 0001
                    P1=~(Num<<n);     //移动后，再取反
                    Delay1ms(100);    //延时100ms
                }
            }
        }
        if(P31==0)	                  //判断K2按键是否按下，P31==0,被按下
        {
            Delay1ms(50);             //消抖
            if(P31==0)		          //判断K2按键是否按下，P31==0,被按下
            {
                while(P31==0);        //等待按键释放

                for(n=0; n<8; n++)    //后面不能加;号
                {
                    Num=0x80;         //右移0X80, 1000 0000
                    P1=~(Num>>n);     //移动后，再取反
                    Delay1ms(100);    //延时100ms
                }
            }
        }
    }
}